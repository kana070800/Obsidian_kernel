가변 인수 함수의 구현 방법? >> printf 함수 확인

8진수 > 권한 정보가 오고 갈 때 사용
16진수 > 메모리 주소 표현 방식

2의 보수의 계산적 이점 > 뒤에서부터 처음 나오는 1 이후로 반전
	올림수 제거 용이
	덧셈으로 뺄셈 구현 가능
	표현 범위의 증가 (음수 개수 1 증가)
	ex)	101100011|100
		  010011100|100
		  0000 0000 0001 0001
		  1111 1111 1110 1111

실수변환 사이트(binaryconvert.com) << IEEE754 규약 사용
실수 양자화 오차 누적 시 주의 (ex적분 연산)
float, double >> double이 더 정밀함
float > int => 단순 소수점 제거
	0.999... 길어지면 1로 인지여부 (기준이 어떤지 확인 필요 >>c 컴파일러 옵션에 따라 다른가?
	
컴퓨터의 처리방식은 짝수반올림방식이 디폴트로 동작한다( n.5 >> 짝수로 이동)
실수 정규화 표기법 = 3.12e-4

<<<실수 정규화 표기법에서 지수의 부호는 어떻게 표기하는가? e+4???>>>
	지수부에 bias(offset)을 부여하여 0승 일 때 1023을 저장, -3승 일 때 1020 저장
ASCII => 'A' == 65, 'a' == 97, '0' == 48
	오름차순, 내림차순 시 ascii 적용가능
	'A' + 32 == 'A' + ('a' - 'A') 성능 차이가 발생하는가?  >> 컴파일러(volatile) 문제 아닌가?
		상수간 연산의 경우 컴파일 타임에 수행됨 >> 같음(디스어셈블 옵션 사용하여 확인)
	int *a = "A" 와 int a = 'A'는 저장되는 장소가 다름 (""은 null도 포함, read only 영역에 저장)

char  >> unsigned char 일수도 signed char 일수도 있다 >> 컴파일러에 따라 달라짐(구분해서 작성하는 것이 안전 or 공통범위만 사용)
sizeof 는 컴파일 타임에 동작한다

typedef 의 사용법 주의
	typedef int INTARR5[5]; //int 배열정의 == INTARR5
	typedef int (*PP)[5];    //int 배열포인터정의 == PP
	
기왕이면 stdint.h 에 정의된 int 타입을 사용 권장(시스템 이식성)
65h, 65LL, 3.5f 처럼 표기하여 byte 조정 가능

{little 엔디안} big 엔디안 >> 우리 시스템은 하위 바이트에 마지막이 저장됨 int a = 0x12345678;
>>0x000000E2E33FF8D4  78 56 34 12    (D4 = 78, D5 = 56, ...)
>
>#include <stdio.h>

int main(void)
{
	char ch1 = 'A';
	char ch2 = 65;
	printf("char %c, ASCII : %d\n", ch1, ch1);
	printf("ASCII : %d, char : %c\n", ch2, ch2);
	
	unsigned char uch1 = -1; //ff
	unsigned char uch2 = 128; //80
	signed char ch11 = -1; //ff
	signed char ch22 = 128; //80
	//메모리 저장방식은 동일, but 변수 해석 방식이 다르기 때문에 다르게 출력된다
	printf("unsigned char(%%u) : %u %u\n", uch1, uch2);
	printf("signed char(%%u)   : %d %d\n", ch11, ch22);
	return 0;
}