자료형 > 몇 바이트, 메모리에 저장된 형태 로부터 파악
float실수 표현 시 뒤에 f를 붙여주지 않으면 double로 인식한다

배열이름, 함수이름 > 포인터 상수
	int a[5];       sizeof(a), sizeof(&a) 는 배열전체 변수공간으로 인식한다(20)
	나머지 포인터는 포인터로 인식(4 in x86)
	a는 시작주소(요소 하나), &a도 시작주소(배열전체를 가리킨다)

구조체 내부 패딩 > 각 맴버 사이 빈공간 (배치 중요, 가급적 작은순부터)

const 선언 시 초기값 수정 불가 
	일반적 변수의 경우 스텍 메모리에 저장되어 read, write 가능
	const 후 변경을 원할 시 [포인터 선언을 통해 변경 가능] 
		const 지역변수의 경우 stack data 영역에 들어간다
		단, const 전역변수의 경우 read only data 영역에 들어간다
		(컴파일러에 따라 상수로 치환하여 text 영역으로 처리할 수도 있음)
		read/write 일수도, read only 일수도 있으니 변경하지 않는 편이 좋다
		
	const int *p  의 경우 *p(값)를 상수처리 (p에 저장된 주소 변경 가능)    (const int)
	int *const p  의 경우 p(주소)를 상수처리 (*p에 저장된 값 변경 가능)    (const p)
	const int *const p 의 경우 둘 다 상수처리

int * p[5] >> 6번째 주소참조(포인터의 배열)
int (* p)[5] >> 배열의 포인터

unsigned int + int >> unsigned int 으로 묵시적 캐스팅---(시험)

51p의 비트연산자 중요

signed 변수의 경우 shift 명령 시 padding value 가 1이 될 수 있기에 주의
	(어셈블리 or 메모리로 확인 필요할 수도)
	
비트 set, clear, toggle ---(시험)

58p 결과의 이유 > printf 내부에서 계산 시 묵시적 캐스팅(int == signed int)
char는 signed char이기에 int 로 묵시적 형변환시 부호비트 유지되면서 padding > 64p 에 설명
	low byte > signed int 로 변환 ,   signed int > unsigned int,   int > double
		why? > 시스템 word 단위로 맞춰 연산하는 것이 빠르기에 이런식으로 계산
		char가 int로 변환시 원래 자신의 signed 여부에 따라 확장시 padding 값이 정해진다
		char, unsigned char는 int로 묵시적 변환 시 signed int 로 변환, padding 값만 달라짐
			(64p ~ 70p)
(시험)

이왕이면 if elseif else 구조는 지양 > 배열 등 자료구조를 통해 해결 방안 모색

자료구조에서 특정 값 검색 시 유용한 구조 > 트리구조






교육학 이론 참조 > 어떻게 공부를 하면 좋을지
코테